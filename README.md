## Алексеев Фёдор Андреевич М8О-104БВ-25
# Лабораторная работа №1
Тема: Разработка консольных калькуляторов на Python (Вариант М3)
## Ограничения по условию
- **Запрещено**: eval, exec, сторонние парсеры.
- **Разрешено**: стандартная библиотека Python.
- Числа: целые и вещественные (формат 123 и 123.45).

## Общие требования для Medium
- Вход: строка со скобками и унарными +/-.
- Приоритеты: 1) унарные; 2) ** (право-ассоц.); 3) * / // %; 4) + -.
- Ограничения: // и % только для целых; деление на ноль — ошибка.
- Проверка ошибок.

## Условия для М3
- Пользователь сразу вводит выражение в обратной польской нотации (например, 3 4 2 * +).
- Алгоритм: читаем токены слева направо, числа кладём в стек, операторы извлекают
аргументы из стека и кладут результат обратно.

# Работа программы

## Входные данные
- Ввод выражения в обратной польской нотации (RPN).
- Используемые операторы: **+**, **-**, , **/**, *, ** *(возведение в степень)*, **//** *(целочисленное деление)*, **%** *(остаток от деления)*.
- Числа вводятся целиком и разделяются пробелами. Унарный знак: **+ -** перед числом без пробела (само число обязательно отделять пробелами с такими унарными знаками), либо **~ $** после числа, пробел после числа не важен.
- Операторы необязательно записывать, разделяя пробелами, в том числе между разными операторами. Но в случаях, если **+ -** стоит перед числом без пробела, оно определится как унарный знак. ** и **//** будут определяться целиком как один оператор, поэтому * и **/** стоит разделять всегда.
- Скобки могут находиться где угодно и обособлять что угодно. Не влияют на порядок вычисления. Единственное условие - все скобки должны открываться и закрываться, одинарные скобки не допускаются.

Вывод: только конечный результат.
# Примеры
```
1 2 +
1 2+
(1 2 3) * + 4 -
(1 2 3)*+4-
2 ~ -5 -
2~ -5 -
9 3 //

Результат для всех примеров > 3
```
## Ошибки при вводе
```
1 2 a bcde@&
```
- Лишние символы 
```
1 2 3 4 +
```
- Не хватает операторов в записи для конечного вычисления
```
1 2 + +
```
- Не хватает чисел в записи для всех операций
```
1 0 /
1 0 // 
1 0 %
```
- Деление на ноль 
```
1.5 0.5 //
1.5 0.5 %
```
- Целочисленное деление/Нахождение остатка только для целых чисел
```
0 1 ~ **
```
- Возведение нуля в отрицательную степень (подразумевает деление на ноль)
```
1 ~ 0.5 **
```
- Возведение отрицательного числа в не целочисленную степень (комплексный результат, согласно ограничениям для лабораторной работы, числа лишь целые и вещественные)

```
(1 2 + 
1 2 +)
```
- Не закрытая (не открытая) скобка
# Алгоритм работы

## Программа состоит из 5 функций
- main() - Запуск программны
- calc() - Вычисление введённого выражения
- get_token() - Создание списка токенов
- correction() - Частичная равка введённого выражения для правильной токенизации
- is_float() - Проверка токена на тип float

Код содержит описания этих функций, а также описания входных и выходных данных в программе.

## main()
Принимает ввод пользователя и передаёт в **calc()**, после чего выводит полученный результат.

## calc()
Обращается к **get_token()** для создания списка токенов, состоящего только из чисел и операторов.
Функция читает токены слева направо, числа кладёт в стек, операторы извлекают аргументы из стека и кладут результат обратно.
Если невозможно прийти к конечному результату (чисел больше, чем операторов, и наоборот) - выдает ошибку. Также выдает ошибку при делении на 0, целочисленном делении и нахождении остатка с не целыми числами, возведении нуля в отрицательную степень, возведении отрицательного числа в не целую степень. Верный конечный результат возвращает в **main()**, сама ничего не выводит.

## get_token()
Создает список токенов. В начале строка разделяется по пробелам: если все числа и операторы уже разделены пробелами, то сразу возвращает список разделенной по пробелам строки.
Если же ввод не такой, то отправляет каждый неопределенный токен в **correction()**. Помимо списка эта фукнция сразу применяет верно расставленные унарные знаки, а также убирает скобки, если они все открыты и закрыты. При неверных унарных знаках или скобках выдает ошибку.

## correction()
Создаёт разделители между всеми операторами, а также ищет лишние символы. При их нахождении выдает ошибку. При успешном разделении и определении токенов возвращает их к **get_token()**.
## is_float()
Вспомогательная функция. Проверяет, является ли токен числом, пытаясь перевести его тип в **float**. Вывод только **True** или **False**.


# Обоснование
## Порядок вычисления и приоритеты
Программа работает с обратной польской нотацией, где порядок вычисления определяется только самой записью. 
Невозможно этот порядок изменить, не меняя саму запись, как например в инфиксной нотации, где добавление или
удаление скобок влияет на приоритет. Алгоритм RPN: запись читается слева направо, оператор применяется к двум предшедствующим числам. Скобки на приоритеты и порядок вычисления никак не влияют, поэтому их, как правило, и не используют. Поэтому они никак не влияют на результат и во время исполнения программы просто удаляются.
```
(1 2 3 +) +
(1 2 3) + +
1 (2 3 +) +
(1 2) 3 + +
1 2 3 (+ +)
Результат везде одинаковый > 6
```
Правила из инфиксной записи не распространяются на другие записи, поэтому никаких требований к обособлениям и приоритетам нет.
Но скобки сами по себе не могут быть однозначны независимо от того, где они используются, должны быть начало и конец обособления. Поэтому это условие программа проверяет и выдает ошибку.

## Токенизация
**get_token()** и **correction()** Позволяют передать для **calc()** только числа и операторы из самых различных и проблематичных для чтения вводов от пользователя.
Разделение логики на **get_token(), correction(), calc()** делает код прозрачным. **correction()** может вовсе не использоваться при
вычислении, поэтому есть смысл разделять алгоритм исправления под отдельную функцию, чтобы не переполнять основную функцию этими проверками. **get_token()** используется всегда и стремится возвращать строго числа и операторы, применяя унарность и избавляясь от скобок,
чтобы в функции **calc()** был алгоритм только прохождения через стек. Каждая из функций выдает различные ошибки: 
- **correction()** - лишние символы
- **get_token()** - неверный ввод для приоритетов 1) и 2) из общих требований для Medium.
- **calc()** - неверный ввод для приоритетов 3) и 4)

# Результаты
- Закрепление основ Python.
- Освоение техник токенизации, стека.
- Освоение разделения логики по функциям.
- Освоение обработок ошибок.
- Освоение написания простых автотестов.



